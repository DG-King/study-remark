<!doctype html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>第七章：正则表达式</title>
</head>
<body>
	<script>
		//正则表达式是一门简单语言的语法规范。它以方法的形式被用于对字符串的信息进行查找、替换和提取操作。可处理正则表达式的方法有regexp.exec、regexp.test、string.match、string.replace、string.search和string.split。
		//1.一个例子
		//这里有一个例子。它是同来匹配URL的正则表达式。在JS中，正则表达式必须写在一行中。正则表达式中的空白是至关重要的：
		var parse_url = /^(?:([A-Za-z]+):)?(\/{0,3})([0-9.\-A-Za-z]+)(?::(\d+))?(?:\/([^?#]*))?(?:\?([^#]*))?(?:#(.*))?$/;
		var url = "http://www.ora.com:80/goodparts?q#frament";
		//让我们来调用parse_url的exec方法。如果能成功地匹配我们传给它的字符串，它将会返回一个数组，该数组包含了从这个url中提取出来的片段：
		var result = parse_url.exec(url);
		var names = ['url', 'scheme', 'slash', 'host', 'port', 'path', 'query', 'hash'];
		var blacnks = '   ';
		var i;
		for (var i = 0; i < names.length; i++) {
			document.writeln(names[i] + ':' + blacnks.substring(names[i].length), result[i]);
		};
		//这段代码产生的结果如下：
		url: http://www.ora.com:80/goodparts?q#frament
		scheme: http
		slash: //
		host: ww.ora.com
		port: 80
		path: goodparts
		query: q
		hash: fragment
		//让我们来看看parse_url的每部分的因子是如何工作的：
		^
		//^字符表示这个字符串的开始。它是一个标记，用来防止exec跳过不像URL的前缀：
		(?:([A-Za-z]+):)?
		//这个因子匹配一个协议名，但仅当它之后跟随一个：（冒号）的时候才匹配。(?:....)表示一个非捕获型分组。后缀?表示这个分组是可选的。
		//它表示重复0或1次。(...)表示一个捕获型分组。一个捕获型分组将复制它所匹配的文本，并将其放入result数组中。每个捕获型分组都将被指定一个编号。第一个捕获型分组的编号是1，所以该分组所匹配的文本拷贝将出现在result[1]中。[...]表示一个字符类。这个字符类A-Za-z包含26个大写字母和26个小写字母。连字符(-)表示范围从A到Z。后缀+表示这个字符将被匹配1次或多次。这个组后面跟着字符:，它将按字面进行匹配：
		(\/{0,3})
		//下一个因子是捕获型分组2。\/表示一个应该被匹配的/(斜杠)。它用\(反斜杠)来进行转义，这样它就不会被错误地解释为这个正则表达式的结束符。后缀(0,3)表示/将被匹配0次，或者1-3次之间：
		([0-9.\-A-Za-z]+)
		//下一个因子是捕获型分组3.它将匹配一个主机名，由1个或多个数字、字母或.或-组成。-将被转义为\-以防止与表示范围的连字符相混淆：
		(?::(\d+))?
		//下一个可选的因子将匹配端口号，它是由一个前置:加上1个或多个数字而组成的序列。\d表示一个数字字符。1个或多个数字组成的数字串将被捕获型分组4捕获:
		(?:\/([^?#]*))?
		//我们有另一个可选的分组。该分组以一个/开始。之后的字符串[^?#]以一个^开始，它表示这个类包含除?和#之外的所有字符。*表示这个字符类将被匹配0次或多次。
		//接下来，我们还有一个以一个?开始的可选分组。它包含捕获型分组6，这个分组包含0个或多个非#字符:
		(?:#(.*))?
		//我们的最后一个可选分组是以#开始的。.将匹配除行结束符以外的所有字符:
		$
		//$表示这个字符串的结束。它让我们确信在这个URL的尾部没有其他更多内容。
		
		//2.结构
		//有两个方法来创建一个RegExo对象。在以前的例子中我们看到，优先的方法是使用正则表达式字面量。
		//正则表达式字面量被包围在一对斜杠中。这有点令人难以捉摸，因为斜杠也被用作除法运算符和注释符。
		//有3个标志能在RegExp中设置。它们分别由字母g(全局匹配)、i(忽略大小写)和m(多行)来标示，这些标志被直接添加在RegExp字面量的末尾:
		//构造一个匹配JS字符串的正则表达式对象
		var my_regexp = /"(?:\\.|[^\\\"])*"/g;
		//创建一个正则表达式的另一个方法是使用RegExp构造器。这个构造器接收一个字符串，并把它编译为一个RegExp对象。创建这个字符串时请多加小心，因为反斜杠在正则表达式和字符串字面量中有一些不同的含义。通常需要双写反斜杠及对引号进行转义:
		//创建一个匹配JS字符串的正则表达式
		var my_regexp = new RegExp("\"(?:\\.|[^\\\\\\"])*\"", 'g');
		//第二个参数是一个指定标志的字符串。RegExp构造器适用于正则表达式必须在运行时动态生成的情形。
		
		//3.元素
		//一个正则表达式选择包含一个或多个正则表达式序列。这些序列被|(竖线)字符分隔。如果这些序列中的任何一项符合匹配条件，那么这个选择就被匹配。它尝试按顺序依次匹配这些序列项目。所以：
		"into".match(/in|int/)
		//将在into中匹配in。但它不会匹配int，因为in已被匹配成功了。
		//一个正则表达式序列包含一个或多个正则表示式因子。每个因子能选择是否跟随一个量词，这个量词决定着这个因子被允许出现的次数。如果没有指定这个量词，那么该因子将别匹配一次。
		//一个正则表达式因子可以是一个字符、一个由圆括号包围的组、一个字符类，或者是一个转义序列。除了控制字符和特殊字符以外，所有字符都将被按照字面处理：
		\/[](){}?+*|.^$
		//如果希望以上的字符按照字面去匹配，那么必须用一个\前缀进行转义。\前缀不能使字母或数字字面化。
		//一个未被转义的.将匹配除行结束符以外的任何字符。
		//正则表达式分组共有4种。
		//（一）捕获型
		//一个捕获型分组是一个被包围在圆括号中的正则表达式选择。任何匹配这个分组的字符将被捕获。每个捕获型分组都被指定了一个数字。在正则表达式中第一个捕获（的分组是1。第二个捕获（的分组是2。
		//（二）非捕获型
		//非捕获型分组有一个(?:前缀。非捕获型分组仅做简单的匹配，并不会捕获所匹配文本。非捕获型分组不会干扰捕获型分组的编号。
		//（三）向前正向匹配
		//向前正向匹配组有一个(?=前缀。它类似非捕获型分组，但在这个组匹配后，文本将倒回到它开始的地方，实际上并不匹配任何东西。
		//（四）向前负向匹配
		//向前负向匹配分组有一个(?!前缀。它类似于向前正向匹配分组，但只有当它匹配失败时它才进行匹配。
		//正则表达式因子可以用一个正则表达式两次后缀用来决定这个因子应该被匹配的次数。包围在一对花括号中的一个数字表示这个因子应该被匹配的次数。如：{3}将匹配3次，{1,6}匹配1-6次任意次数，{2,}匹配至少两次或更多。
		//？等同于{0,1}。*等同于{0,}。+等同于{1,}。
		//如果只有一个量词，则趋向于进行贪婪性匹配，即匹配尽可能多的重复直至达到上限。如果这个量词还有一个额外的后缀?，那么则趋向于进行懒惰性匹配，即试图匹配尽可能少的必要重复。一般情况下最好坚持使用贪婪性匹配。
	</script>
</body>
</html>