<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>第四章：优化</title>
</head>
<body>
    <script>
        // 本章主要在于优化开发体验，提高开发效率。

        // 1 缩小文件搜索范围
        // Webpack 启动后会从配置的 Entry 出发，解析出文件中的导入语句，再递归的解析。 在遇到导入语句时 Webpack 会做两件事情：
        // 根据导入语句去寻找对应的要导入的文件。例如 require('react') 导入语句对应的文件是 ./node_modules/react/react.js，require('./util') 对应的文件是 ./util.js。
        // 根据找到的要导入文件的后缀，使用配置中的 Loader 去处理文件。例如使用 ES6 开发的 JavaScript 文件需要使用 babel-loader 去处理。
        // 以上两件事情虽然对于处理一个文件非常快，但是当项目大了以后文件量会变的非常多，这时候构建速度慢的问题就会暴露出来。
        // 虽然以上两件事情无法避免，但需要尽量减少以上两件事情的发生，以提高速度。
        // 优化 loader 配置
        // Loader 可以通过 test 、 include 、 exclude 三个配置项来命中 Loader 要应用规则的文件。 为了尽可能少的让文件被 Loader 处理，可以通过 include 去命中只有哪些文件需要被处理。
        // 优化 resolve.modules 配置
        // 当安装的第三方模块都放在项目根目录下的 ./node_modules 目录下时，没有必要按照默认的方式去一层层的寻找，可以指明存放第三方模块的绝对路径，以减少寻找
        // 优化 resolve.mainFields 配置
        // 优化 resolve.alias 配置
        // 优化 resolve.extensions 配置
        // 优化 module.noParse 配置

        // 2 使用 DllPlugin
        // 在介绍 DllPlugin 前先给大家介绍下 DLL。 用过 Windows 系统的人应该会经常看到以 .dll 为后缀的文件，这些文件称为动态链接库，在一个动态链接库中可以包含给其他模块调用的函数和数据。
        // 要给 Web 项目构建接入动态链接库的思想，需要完成以下事情：
        // 把网页依赖的基础模块抽离出来，打包到一个个单独的动态链接库中去。一个动态链接库中可以包含多个模块。
        // 当需要导入的模块存在于某个动态链接库中时，这个模块不能被再次被打包，而是去动态链接库中获取。
        // 页面依赖的所有动态链接库需要被加载。
        // 为什么给 Web 项目构建接入动态链接库的思想后，会大大提升构建速度呢？ 原因在于包含大量复用模块的动态链接库只需要编译一次，在之后的构建过程中被动态链接库包含的模块将不会在重新编译，而是直接使用动态链接库中的代码。 
        // 由于动态链接库中大多数包含的是常用的第三方模块，例如 react、react-dom，只要不升级这些模块的版本，动态链接库就不用重新编译。
        // 接入 Webpack
        // Webpack 已经内置了对动态链接库的支持，需要通过2个内置的插件接入，它们分别是：
        // DllPlugin 插件：用于打包出一个个单独的动态链接库文件。
        // DllReferencePlugin 插件：用于在主要配置文件中去引入 DllPlugin 插件打包好的动态链接库文件。

        // 3 使用 HappyPack
        // 由于有大量文件需要解析和处理，构建是文件读写和计算密集型的操作，特别是当文件数量变多后，Webpack 构建慢的问题会显得严重。 
        // 运行在 Node.js 之上的 Webpack 是单线程模型的，也就是说 Webpack 需要处理的任务需要一件件挨着做，不能多个事情一起做。
        // 文件读写和计算操作是无法避免的，那能不能让 Webpack 同一时刻处理多个任务，发挥多核 CPU 电脑的威力，以提升构建速度呢？
        // HappyPack 就能让 Webpack 做到这点，它把任务分解给多个子进程去并发的执行，子进程处理完后再把结果发送给主进程。
        // 由于 JavaScript 是单线程模型，要想发挥多核 CPU 的能力，只能通过多进程去实现，而无法通过多线程实现。
        // 分解任务和管理线程的事情 HappyPack 都会帮你做好，你所需要做的只是接入 HappyPack。
        // HappyPack 原理
        // 在整个 Webpack 构建流程中，最耗时的流程可能就是 Loader 对文件的转换操作了，因为要转换的文件数据巨多，而且这些转换操作都只能一个个挨着处理。 
        // HappyPack 的核心原理就是把这部分任务分解到多个进程去并行处理，从而减少了总的构建时间。
        // 从前面的使用中可以看出所有需要通过 Loader 处理的文件都先交给了 happypack/loader 去处理，收集到了这些文件的处理权后 HappyPack 就好统一分配了。
        // 每通过 new HappyPack() 实例化一个 HappyPack 其实就是告诉 HappyPack 核心调度器如何通过一系列 Loader 去转换一类文件，并且可以指定如何给这类转换操作分配子进程。
        // 核心调度器的逻辑代码在主进程中，也就是运行着 Webpack 的进程中，核心调度器会把一个个任务分配给当前空闲的子进程，子进程处理完毕后把结果发送给核心调度器，它们之间的数据交换是通过进程间通信 API 实现的。
        // 核心调度器收到来自子进程处理完毕的结果后会通知 Webpack 该文件处理完毕。

        // 4 使用 ParallelUglifyPlugin
        // 在使用 Webpack 构建出用于发布到线上的代码时，都会有压缩代码这一流程。 最常见的 JavaScript 代码压缩工具是 UglifyJS，并且 Webpack 也内置了它。

        // 5 使用自动刷新
        // 在开发阶段，修改源码是不可避免的操作。 对于开发网页来说，要想看到修改后的效果，需要刷新浏览器让其重新运行最新的代码才行。 虽然这相比于开发原生 iOS 和 Android 应用来说要方便很多，因为那需要重新编译这个项目再运行，但我们可以把这个体验优化的更好。 
        // 借助自动化的手段，可以把这些重复的操作交给代码去帮我们完成，在监听到本地源码文件发生变化时，自动重新构建出可运行的代码后再控制浏览器刷新。
        // 自动刷新的原理
        // 控制浏览器刷新有三种方法：
        // 借助浏览器扩展去通过浏览器提供的接口刷新，WebStorm IDE 的 LiveEdit 功能就是这样实现的。
        // 往要开发的网页中注入代理客户端代码，通过代理客户端去刷新整个页面。
        // 把要开发的网页装进一个 iframe 中，通过刷新 iframe 去看到最新效果。
        // DevServer 支持第2、3种方法，第2种是 DevServer 默认采用的刷新方法。

        // 6 开启模块热替换
        // 要做到实时预览，除了在5使用自动刷新中介绍的刷新整个网页外，DevServer 还支持一种叫做模块热替换(Hot Module Replacement)的技术可在不刷新整个网页的情况下做到超灵敏的实时预览。 
        // 原理是当一个源码发生变化时，只重新编译发生变化的模块，再用新输出的模块替换掉浏览器中对应的老模块。
        // 模块热替换技术的优势有：
        // 实时预览反应更快，等待时间更短。
        // 不刷新浏览器能保留当前网页的运行状态，例如在使用 Redux 来管理数据的应用中搭配模块热替换能做到代码更新时 Redux 中的数据还保持不变。
        // 总的来说模块热替换技术很大程度上的提高了开发效率和体验。
        // 模块热替换的原理
        // 模块热替换的原理和自动刷新原理类似，都需要往要开发的网页中注入一个代理客户端用于连接 DevServer 和网页， 不同在于模块热替换独特的模块替换机制。

        // 7 区分环境
        // 为什么需要区分环境
        // 在开发网页的时候，一般都会有多套运行环境，例如：
        // 在开发过程中方便开发调试的环境。
        // 发布到线上给用户使用的运行环境。
        // 为了尽可能的复用代码，在构建的过程中需要根据目标代码要运行的环境而输出不同的代码，我们需要一套机制在源码中去区分环境。 幸运的是 Webpack 已经为我们实现了这点。

        // 8 压缩代码
        // 浏览器从服务器访问网页时获取的 JavaScript、CSS 资源都是文本形式的，文件越大网页加载时间越长。 为了提升网页加速速度和减少网络传输流量，可以对这些资源进行压缩。 
        // 压缩的方法除了可以通过 GZIP 算法对文件压缩外，还可以对文本本身进行压缩。
        // 对文本本身进行压缩的作用除了有提升网页加载速度的优势外，还具有混淆源码的作用。 由于压缩后的代码可读性非常差，就算别人下载到了网页的代码，也大大增加了代码分析和改造的难度。
        // 目前最成熟的 JavaScript 代码压缩工具是 UglifyJS ， 它会分析 JavaScript 代码语法树，理解代码含义，从而能做到诸如去掉无效代码、去掉日志输出代码、缩短变量名等优化。
        // CSS 代码也可以像 JavaScript 那样被压缩，以达到提升加载速度和代码混淆的作用。 目前比较成熟可靠的 CSS 压缩工具是 cssnano，基于 PostCSS。

        // 9 CDN 加速
        // 什么是 CDN
        // 虽然前面通过了压缩代码的手段来减小网络传输大小，但实际上最影响用户体验的还是网页首次打开时的加载等待。 导致这个问题的根本是网络传输过程耗时大，CDN 的作用就是加速网络传输。
        // CDN 又叫内容分发网络，通过把资源部署到世界各地，用户在访问时按照就近原则从离用户最近的服务器获取资源，从而加速资源的获取速度。 CDN 其实是通过优化物理链路层传输过程中的网速有限、丢包等问题来提升网速的
        // 用 Webpack 实现 CDN 的接入
        // 总结上面所说的，构建需要实现以下几点：
        // 静态资源的导入 URL 需要变成指向 CDN 服务的绝对路径的 URL 而不是相对于 HTML 文件的 URL。
        // 静态资源的文件名称需要带上有文件内容算出来的 Hash 值，以防止被缓存。
        // 不同类型的资源放到不同域名的 CDN 服务上去，以防止资源的并行加载被阻塞。

        // 10 使用 Tree Shaking
        // Tree Shaking 可以用来剔除 JavaScript 中用不上的死代码。它依赖静态的 ES6 模块化语法，例如通过 import 和 export 导入导出。 Tree Shaking 最先在 Rollup 中出现，Webpack 在 2.0 版本中将其引入。

        // 11 提取公共代码
        // 为什么需要提取公共代码
        // 大型网站通常会由多个页面组成，每个页面都是一个独立的单页应用。 但由于所有页面都采用同样的技术栈，以及使用同一套样式代码，这导致这些页面之间有很多相同的代码。
        // 如果每个页面的代码都把这些公共的部分包含进去，会造成以下问题：
        // 相同的资源被重复的加载，浪费用户的流量和服务器的成本；
        // 每个页面需要加载的资源太大，导致网页首屏加载缓慢，影响用户体验。
        // 如果把多个页面公共的代码抽离成单独的文件，就能优化以上问题。 原因是假如用户访问了网站的其中一个网页，那么访问这个网站下的其它网页的概率将非常大。 
        // 在用户第一次访问后，这些页面公共代码的文件已经被浏览器缓存起来，在用户切换到其它页面时，存放公共代码的文件就不会再重新加载，而是直接从缓存中获取。 这样做后有如下好处：
        // 减少网络传输流量，降低服务器成本；
        // 虽然用户第一次打开网站的速度得不到优化，但之后访问其它页面的速度将大大提升。
        // 如何通过 Webpack 提取公共代码
        // Webpack 内置了专门用于提取多个 Chunk 中公共部分的插件 CommonsChunkPlugin

        // 12 分割代码按需加载
        // 为什么需要按需加载
        // 随着互联网的发展，一个网页需要承载的功能越来越多。 
        // 对于采用单页应用作为前端架构的网站来说，会面临着一个网页需要加载的代码量很大的问题，因为许多功能都集中的做到了一个 HTML 里。 这会导致网页加载缓慢、交互卡顿，用户体验将非常糟糕。
        // 导致这个问题的根本原因在于一次性的加载所有功能对应的代码，但其实用户每一阶段只可能使用其中一部分功能。 所以解决以上问题的方法就是用户当前需要用什么功能就只加载这个功能对应的代码，也就是所谓的按需加载。
        // 用 Webpack 实现按需加载
        // Webpack 内置了强大的分割代码的功能去实现按需加载，实现起来非常简单。
        // Webpack 内置了对 import(*) 语句的支持
        // 为了正确的输出在 /* webpackChunkName: "show" */ 中配置的 ChunkName，还需要配置下 Webpack

        // 13 使用 Prepack
        // 在前面的优化方法中提到了代码压缩和分块，这些都是在网络加载层面的优化，除此之外还可以优化代码在运行时的效率，Prepack 就是为此而生。
        // Prepack 由 Facebook 开源，它采用较为激进的方法：在保持运行结果一致的情况下，改变源代码的运行逻辑，输出性能更高的 JavaScript 代码。 
        // 实际上 Prepack 就是一个部分求值器，编译代码时提前将计算结果放到编译后的代码中，而不是在代码运行时才去求值。
        // 接入 Webpack
        // Prepack 需要在 Webpack 输出最终的代码之前，对这些代码进行优化，就像 UglifyJS 那样。 
        // 因此需要通过新接入一个插件来为 Webpack 接入 Prepack，幸运的是社区中已经有人做好了这个插件：prepack-webpack-plugin。

        // 14 开启 Scope Hoisting
        // Scope Hoisting 可以让 Webpack 打包出来的代码文件更小、运行的更快， 它又译作 "作用域提升"，是在 Webpack3 中新推出的功能。

        // 15 输出分析
        // 前面虽然介绍了非常多的优化方法，但这些方法也无法涵盖所有的场景，为此你需要对输出结果做分析，以决定下一步的优化方向。
        // 最直接的分析方法就是去阅读 Webpack 输出的代码，但由于 Webpack 输出的代码可读性非常差而且文件非常大，这会让你非常头疼。 为了更简单直观的分析输出结果，社区中出现了许多可视化的分析工具。
        // 这些工具以图形的方式把结果更加直观的展示出来，让你快速看到问题所在。 接下来教你如何使用这些工具。
        // 在启动 Webpack 时，支持两个参数，分别是：
        // --profile：记录下构建过程中的耗时信息；
        // --json：以 JSON 的格式输出构建结果，最后只输出一个 .json 文件，这个文件中包括所有构建相关的信息。
        // 官方的可视化分析工具
        // Webpack 官方提供了一个可视化分析工具 Webpack Analyse，它是一个在线 Web 应用。

        // 16 优化总结
        // 本章从开发体验和输出质量两个角度讲解了如何优化项目中的 Webpack 配置，这些优化的方法都是来自项目实战中的经验积累。 
        // 虽然每一小节都是一个个独立的优化方法，但是有些优化方法并不冲突可以相互组合，以达到最佳的效果。
    </script>
</body>
</html>